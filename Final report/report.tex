\documentclass[a4paper]{article}

\usepackage{times}
\usepackage[english]{babel}

% -----------------------------------------------
% especially use this for you code
% -----------------------------------------------

\usepackage{courier}
\usepackage{listings}
\usepackage{color}

\definecolor{Gray}{gray}{0.95}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{language=C++,
	basicstyle = \small\ttfamily,   % the size and fonts that are used
	frame = single,                 % adds a frame around the code
	tabsize = 4,                    % sets default tabsize
	breaklines = true,              % sets automatic line breaking
	numbers = left,                 % where to put the line-numbers
	numberstyle = \footnotesize,    % the style of the line-numbers
	keywordstyle=\color{blue}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	commentstyle=\color{mygreen}\ttfamily,
	keepspaces=true,
	showspaces=false,
	showstringspaces=false,
}

\lstdefinestyle{DOS}
{
    backgroundcolor=\color{black},
    basicstyle=\small\color{white}\ttfamily
}

\begin{document}


\title{Programming report \\
       Week 2 Assignments C++
}
\date{\today}
\author{Jaime Betancor Valado \\
Christiaan Steenkist \\
Remco Bos \\
Diego Ribas Gomes
}

\maketitle

\section*{Assignment 10, Text Changer}
We were tasked with making a program that changes the text of an input file in different ways as lower case everything, upper case everything, capitalize first letter of each line, etc. For that we were asked to implement a menu with the different functionalities and some functions to handle the options.

\subsection*{Code Listings}
\lstinputlisting[caption = \tt main.ih]{src/a10/ex10.ih}
\lstinputlisting[caption = \tt main.cc]{src/a10/main.cc}
\lstinputlisting[caption = \tt arguments.cc]{src/a10/arguments.cc}
\lstinputlisting[caption = \tt capitalize.cc]{src/a10/capitalizefile.cc}
\lstinputlisting[caption = \tt lowercasefile.cc]{src/a10/lowercasefile.cc}
\lstinputlisting[caption = \tt process.cc]{src/a10/process.cc}
\lstinputlisting[caption = \tt readfile.cc]{src/a10/readfile.cc}
\lstinputlisting[caption = \tt usage.cc]{src/a10/usage.cc}

\section*{Assignment 11, Questions - It is appropiate to?}
Here are the answers and the examples for the questions of assigment 11.

\subsection*{define an int-type parameter}
It is appropriate to use an int-type paramater when an int-type value passed as argument must keep its original value after use. In the code example this is illustrated because it shows a function that adds 2 to the variable, and keeps it original value to use for squaring the int-value.
\lstinputlisting[caption = \tt example]{src/a11/1.cc}
\subsection*{define a std::string value parameter}
It is appropriate to use a std::string value parameter when a std::string variable needs to be passed as argument and have multiple copies, but keeping its original value where it is defined. In the code example this is illustrated, because a std::string is first modified to show the std::string without blanks, later the original std::string value is used to capitalize all characters.
\lstinputlisting[caption = \tt example]{src/a11/2.cc}
\subsection*{define a const reference to an int-type parameter}
It is appropriate to use a const reference to an int-type parameter if the int-type referenced to must not be modified, but that int-type value must be passed as argument. It is somewhat similar to pass by value, however pass by const reference improves performance if big objects are passed, because no copy is made. Hence there is no characteristic situation, because passing by value has the same result.
\subsection*{define a const referente to a std::string value parameter}
It is appropriate to use a const reference to a std::string value parameter if the std::string referenced too must not be modified but used somewhere else. assing big objects by const reference improves performance, because no copy is made in memory. The std::string is read-only in this case. In the code example this is illustrated, because a big file is passed to the function after which a specific word is to be found in the file and that shows its occurence.
\lstinputlisting[caption = \tt example]{src/a11/4.cc}
\subsection*{define a non-const reference to an int-type parameter}
It is appropriate to use a non-const reference int-type parameter if the int-type value must not be copied and must be modified. In the code example this is illustrated, because the int-type value is used and modified by a function that does one operation on the int-type.
\lstinputlisting[caption = \tt example]{src/a11/5.cc}
\subsection*{define a non-const reference to a std::string value parameter}
It is appropriate to use a non-const reference std::string value paramater if the std::string is modified but no copy is needed. In the code example this is illustrated, because the blanks of the std::string are removed by a function.
\lstinputlisting[caption = \tt example]{src/a11/6.cc}
\subsection*{define a const rvalue-reference to an int-type parameter}
It is appropriate to use a const rvalue-reference int-type parameter if we need an unmodifiable reference to an int-type, however this is easier done with a const lvalue reference.
\subsection*{define a const rvalue-reference to a std::string parameter}
It is appropriate to use a const rvalue-reference std::string value if we need an unmodifiable reference to a std::strin value, however this is easier done with a const lvalue reference.
\subsection*{define a rvalue-reference to an int-type parameter}
It is appropriate to use a non-const rvalue-reference int-type parameter if we need a reference to a returned anonymous variable. This can also be done with an lvalue-reference,however this needs copying. In the code example this is illustrated, because it uses the anonymous variable as argument to display if the anonymous variable is an rvalue.
\lstinputlisting[caption = \tt example]{src/a11/9.cc}
\subsection*{define a rvalue-reference to a std::string parameter}
It is appropriate to use a non-const rvalue-reference std::string value to use a temporary string as argument. In the code example this is illustrated, because it shows the temporary string as output.
\lstinputlisting[caption = \tt example]{src/a11/10.cc}
\subsection*{define an int-type value}
It is appropriate to return an int-type value when a variable declared inside the function must be returned. In the code example this is illustrated, because an operation on a local variable with the function argument is performed.
\lstinputlisting[caption = \tt example]{src/a11/11.cc}
\subsection*{define a std::string value}
It is appropriate to return a std::string value when a std::string declared inside the function must be returned.In the code example this is illustrated, because a local std::string is merged with the function argument and returned.
\lstinputlisting[caption = \tt example]{src/a11/12.cc}
\subsection*{define a const reference to an int}
It is appropriate to return a const reference to an int-type parameter when the returned int-type variable must be unmodifiable and not be copied. An example can be to pass a constant numeric value to different functions, however this may not be useful. Because a constant numeric value is often not used in many situations. If you want a constant number to be defined, like the age of a person which must not be modified and shown later, then a std::string is more useful.
\subsection*{define a const reference to a std::string}
It is appropriate to return a const reference to a std::string value if a std::string value must remain unmodified and being the only instance that there is. It also improves performance. In the code example this is illustrated as a function that obtains a name of a person and then prints it (in a real program this may be used to define the name in a database).
\lstinputlisting[caption = \tt example]{src/a11/14.cc}
\subsection*{define a non-const reference to an int}
It is appropriate to return a reference to an int-type parameter when the int-type variable itself must be returned instead of its value and making a copy of it, however only global variables can be used. In the code example this is illustrated because the global variable referenced to is used in the main function on the left side of an assignment statement. The global variable receives the value assigned to it.
\lstinputlisting[caption = \tt example]{src/a11/15.cc}
\subsection*{define a non-const reference to a std::string}
It is appropriate to return a reference to a std::string value when the std::string variable itself must be returned instead of its value and making a copy of it, however only global variables can be used. In the code example this is illustrated because the global variable referenced to is used in the main function on the left side of an assignment statement. The global variable receives the value assigned to it.
\lstinputlisting[caption = \tt example]{src/a11/16.cc}
\subsection*{define a const rvalue-reference to an int}
It is never appropriate to return a const rvalue reference  to an int-type and it is also never appropriate to return a non-const rvalue reference to an int-type because the int-type rvalue has a lifetime lower than the function and does not exist longer. It is better to return by value because you want to use the value of the int-type variable. And if the int-type does exist longer than the function lifetime, you only win some efficiency in not having a copy. The int-type object is small and the compiler can take care of of copies.
\subsection*{define a const rvalue-reference to a std::string}
It is sometimes appropriate to return a non-const rvalue reference or a const rvalue reference to a std::string in the case of move semantics. However a move constructor is already present for the return type of a std::string, so returning the std::string by value is ok and the compiler takes care of that.

\section*{Assignment 12, Big Numbers}
We were tasked with making a function that prints unsigned long longs with separators.
We are proud to announce the recursive \texttt{printBig} function.
The non-recursive variant of this amazing function will be revealed at a later date (at the resubmit mayhaps).

\subsection*{Code Listings}
\lstinputlisting[caption = \tt bignum.h]{src/a12/bignum.h}
\lstinputlisting[caption = \tt printbig.cc]{src/a12/printbig1.cc}
\lstinputlisting[caption = \tt printsmall.cc]{src/a12/splitdigits.cc}

\section*{Assignment 13, Fibonacci}
We were tasked with making an efficent as well as a horribly inefficient way of calculating Fibonacci numbers.
The functions \texttt{fib} and \texttt{rawfib} are the two methods we implemented to give you these fascinating numbers.

\subsection*{Time Tests}
To show how absolutely primitive \texttt{rawfib} is we did a timing test where both functions were tasked with calculating the Fibonacci numbers at places 0 through 41. Here are the results of these tests with at the top the performance of our beloved \texttt{fib} function and at the bottom the noticably slower \texttt{rawfib}.

\begin{itemize}
\item \texttt{time ./main 41} gave a real time of 0m0.043s
\item \texttt{time ./main 41 x} gave a real time of 1m37.808s
\end{itemize}

%\begin{itemize}
%\item \texttt{time ./main 41} gave a real of 0m0.041s
%\item \texttt{time ./main 41 x} gave a real of 1m48.889s
%\end{itemize}

\subsection*{Code Listings}
\lstinputlisting[caption = \tt main.h]{src/a13o/main.h}
\lstinputlisting[caption = \tt main.cc]{src/a13o/main.cc}
\lstinputlisting[caption = \tt fib.cc]{src/a13o/fib.cc}
\lstinputlisting[caption = \tt rawfib.cc]{src/a13o/rawfib.cc}

%\lstinputlisting[caption = \tt main.h]{src/a13n/main.h}
%\lstinputlisting[caption = \tt main.cc]{src/a13n/main.cc}
%\lstinputlisting[caption = \tt fib1.cc]{src/a13n/fib1.cc}
%\lstinputlisting[caption = \tt fib2.cc]{src/a13n/fib2.cc}
%\lstinputlisting[caption = \tt rawfib.cc]{src/a13n/rawfib.cc}

\section*{Assignment 14, Evaluator}
We were tasked with designing a program that evaluates the design quality of a program.
The design quality can roughly be translated to the number of comments divided by the number of lines and is said to be an indicator for the quality of source files.

\subsection*{Score Calculations}
The actual design quality is calculated by taking the ratio of two scores.
These scores are the line scores and comment scores which are based on the number of lines and comments.
Every line counts only once but after 30 lines they count double and at an indentation above 3 they count doubly as well.
Every end of line comment counts but c-style comments only fully count when they are at the start of a file, otherwise they only contribute one point per block.

\subsection*{Code Listings}
\lstinputlisting[caption = \tt main.h]{src/a14/main.h}
\lstinputlisting[caption = \tt main.cc]{src/a14/main.cc}
\lstinputlisting[caption = \tt computequality.cc]{src/a14/computequality.cc}
\lstinputlisting[caption = \tt computescores.cc]{src/a14/computescores.cc}
\lstinputlisting[caption = \tt endcomment.cc]{src/a14/endcomment.cc}
\lstinputlisting[caption = \tt endline.cc]{src/a14/endline.cc}
\lstinputlisting[caption = \tt getinput.cc]{src/a14/getinput.cc}
\lstinputlisting[caption = \tt printscores.cc]{src/a14/printscores.cc}
\lstinputlisting[caption = \tt startcomment.cc]{src/a14/startcomment.cc}

\section*{Assignment 15, Bit Shifts}
We were tasked with making a program that can use three different methods to find the most significant big.
These methods use bit shifts, taking a logarithm and truncating and binary search.
It should also return the least significant bit.

\subsection*{Time Tests}
We did tests on big and large numbers for every method.
The methods in order are \texttt{shiftSearch}, \texttt{truncateSearch} and \texttt{binarySearch}.

\begin{itemize}
\item Shift search: \texttt{time ./main 10 1 30000000} gave a real of 0m0.238s
\item Truncate search: \texttt{time ./main 10 2 30000000} gave a real of 0m2.919s
\item Binary search: \texttt{time ./main 10 3 30000000} gave a real of 0m0.859s
\end{itemize}

\begin{itemize}
\item Shift search: \texttt{time ./main 18446744073709551615 1 30000000} gave a real of 0m4.978s
\item Truncate search: \texttt{time ./main 18446744073709551615 2 30000000} gave a real of 0m2.904s
\item Binary search: \texttt{time ./main 18446744073709551615 3 30000000} gave a real of 0m0.874s
\end{itemize}

\subsection*{Results}
It seems that the first method is better for the low values and the binary is almost constant in spite of the value and is the best with large numbers. The second one is also almost constant in time in spite of the value but in low values is the slow process and in high values the binary outperforms it in matters of time.

\subsection*{Code Listings}
\lstinputlisting[caption = \tt main.h]{src/a15/main.h}
\lstinputlisting[caption = \tt main.cc]{src/a15/main.cc}
\lstinputlisting[caption = \tt binary.cc]{src/a15/binary.cc}
\lstinputlisting[caption = \tt lsb.cc]{src/a15/lsb.cc}
\lstinputlisting[caption = \tt shift.cc]{src/a15/shift.cc}
\lstinputlisting[caption = \tt truncate.cc]{src/a15/truncate.cc}

\section*{Assignment 16, Cipher}
We were tasled with making a Vigenère cipher program.
The idea of the program is to implement a Vigenère cipher that can translate newlines, tabs and all printable characters.

\subsection*{Design}
To encrypt and decrypt the program goes through 3 simple steps for each character.
First the program translates the character to a compressed ascii table using the \texttt{compressChar} function.
This makes the character inhabit a range of numbers from zero to the total number of character minus one.
The second step is shifting the compressed character by the right amount.
For this the apropriate character in the cipher is used after it has also been compressed.
After the shift the now translated character is shifted back into the normal ascii table again and printed.

\subsection*{Code Listings}
\lstinputlisting[caption = \tt main.ih]{src/a16/main.ih}
\lstinputlisting[caption = \tt main.cc]{src/a16/main.cc}
\lstinputlisting[caption = \tt arguments.cc]{src/a16/arguments.cc}
\lstinputlisting[caption = \tt compresschar.cc]{src/a16/compresschar.cc}
\lstinputlisting[caption = \tt decompresschar.cc]{src/a16/decompresschar.cc}
\lstinputlisting[caption = \tt process.cc]{src/a16/process.cc}

\section*{Assignment 17, Create a library}
We were tasked with creating a library, show how to do it and how we compiled it. All functions are in a file called library.a and the command that we used to create it is: \\* \\* 
\texttt{ar rvs librvalue.a arguments.o compresschar.o    \\*       decompresschar.o process.o} \\* \\* 
And finally, we compiled the program typing make in the terminal with this makefile file:
\subsection*{}
\lstinputlisting[caption = \tt makefile]{src/a17/makefile}


\end{document}