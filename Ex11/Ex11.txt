- It is appropriate to use an int-type paramater when an int-type value
passed as argument must keep its original value after use. In the code example
this is illustrated because it shows a function that adds 2 to the variable,
and keeps it original value to use for squaring the int-value.

void add2(int y)
{
    std::cout << "y = " << y + 2<< '\n';
}

void square(int z)
{
    std::cout << "z = " << z * z << '\n';

int main()
{
    int x = 5;
    std::cout << "x = " << x << '\n'; // x = 5

    add2(x);			      // x = 7
    square(x)                         // x = 25

    std::cout << "x = " << x << '\n'; // x = 5

}

- It is appropriate to use a std::string value parameter when
a std::string variable needs to be passed as argument and have
multiple copies, but keeping its original value where it is defined.
In the code example this is illustrated, because a std::string is first modified
to show the std::string without blanks, later the original std::string value
is used to capitalize all characters.

int main()
{
    std::string newString;
    removeBlanks(newString); // removes blanks and prints the modified string
    capitalizeString(newString); // capitalizes the original string,
                                 // so it still has blanks if they were present
}

- It is appropriate to use a const reference to an int-type parameter if the
int-type referenced to must not be modified, but that int-type value must be
passed as argument. It is somewhat similar to pass by value,
however pass by const reference improves performance if big objects are passed,
because no copy is made. Hence there is no characteristic situation,
because passing by value has the same result.

- It is appropriate to use a const reference to a std::string value parameter
if the std::string referenced too must not be modified but used somewhere else.
Passing big objects by const reference improves performance,
because no copy is made in memory. The std::string is read-only in this case.
In the code example this is illustrated, because a big file is passed
to the function after which a specific word is to be found in the file and that
shows its occurence.

int main()
{
  std::string fileName = readFile();
  occurrence(fileName);

}

void occurence(std::string const& fileName)
{
  // code to find occurrence of a chosen word by user
}

- It is appropriate to use a non-const reference int-type parameter if the
int-type value must not be copied and must be modified. In the code example
this is illustrated, because the int-type value is used and modified
by a function that does one operation on the int-type.

int main()
{
  int x = 5;

  square();

  std::cout << x;
}

int square(int &x)
{
  return x * x;
}

- It is appropriate to use a non-const reference std::string value paramater
if the std::string is modified but no copy is needed. In the code example this
is illustrated, because the blanks of the std::string are removed by a function.

int main()
{
  std::string withBlanks = "There are blanks";
  removeBlanks(withBlanks);
  std::cout << withBlanks;
}

void removeBlanks(std::string &withBlanks)
{
  // code to remove all blanks from string
}

- It is appropriate to use a const rvalue-reference int-type parameter
if we need an unmodifiable reference to an int-type, however this is easier
done with a const lvalue reference.

_ It is appropriate to use a const rvalue-reference std::string value
if we need an unmodifiable reference to a std::strin value, however this is
easier done with a const lvalue reference.

- It is appropriate to use a non-const rvalue-reference int-type parameter
if we need a reference to a returned anonymous variable. This can also be
done with an lvalue-reference,however this needs copying. In the code example
this is illustrated, because it uses the anonymous variable as argument
to display if the anonymous variable is an rvalue.

int intVal()
{
  return 5;
}

void receive(int &value)
{
  std::cout << "int value parameter\n";
}

void receive(int &&value)
{
  std::cout << "int R-value parameter\n";
}

int main()
{
  receive(18); // 18 is anonymous variable, hence rvalue
  int value = 5;
  receive(value); // value is lvalue
  receive(intVal()); // the number returned by intVal() is anonymous, hence rvalue
}

- It is appropriate to use a non-const rvalue-reference std::string value to
use a temporary string as argument. In the code example this is illustrated,
because it shows the temporary string as output.

std::string returnString()
{
  return "temporary string";
}

void receive(std::string &value)
{
  std::cout << "string value parameter\n";
}

void receive(std::string &&value)
{
  std::cout << "string R-value parameter\n";
}


int main()
{
  std::string newString = "newString";
  receive(newString);           // newString is lvalue
  receive(returnString());      // returnStrings return std::string is temporary
}

- It is appropriate to return an int-type value when a variable declared inside
the function must be returned. In the code example this is illustrated,
because an operation on a local variable with the function argument is performed.

int squareLocal(int x)
{
  int value = x * 2;
  return value;
}

- It is appropriate to return a std::string value when a std::string declared
inside the function must be returned.In the code example this is illustrated,
because a local std::string is merged with the function argument and returned;

std::string mergeStrings(std::string argString)
{
  std::string localString = "Hello";
  std::string newString = localString + argString;
  return newString;
}

- It is appropriate to return a const reference to an int-type parameter when
the returned int-type variable must be unmodifiable and not be copied.
An example can be to pass a constant numeric value to different functions,
however this may not be useful. Because a constant numeric value is often not
used in many situations. If you want a constant number to be defined,
like the age of a person which must not be modified and shown later,
then a std::string is more useful.

- It is appropriate to return a const reference to a std::string value
if a std::string value must remain unmodified and being the only instance that there is.
It also improves performance. In the code example this is illustrated as a
function that obtains a name of a person and then prints it
(in a real program this may be used to define the name in a database).

name = "Willem";

const std::string& getName()
{
  return name;
}

int main()
{
  std::cout << getName();
}

- It is appropriate to return a reference to an int-type parameter when the
int-type variable itself must be returned instead
of its value and making a copy of it, however only global variables can be used.
In the code example this is illustrated
because the global variable referenced to is used in the main function on the
left side of an assignment statement.
The global variable receives the value assigned to it.

int n;
int& test()

{
    return n;
}

int main()
{
    test() = 5; // test() is replaced with the returned n, which then receives the value 5
    cout << n;
    return 0;
}

- It is appropriate to return a reference to a std::string value when the
std::string variable itself must be returned instead
of its value and making a copy of it, however only global variables can be used.
In the code example this is illustrated
because the global variable referenced to is used in the main function on the
left side of an assignment statement.
The global variable receives the value assigned to it.

std::string newString;
std::string& test()

{
    return newString;
}

int main()
{
    test() = "Test this string\n"; // test() is replaced with the returned
                                   // std::string variable, which then receives
                                   // the value "Test this string\n"
    cout << newString;
    return 0;
}

- It is never appropriate to return a const rvalue reference  to an int-type and
it is also never appropriate to return a non-const rvalue reference to an int-type
because the int-type rvalue has a lifetime lower than the function and does not exist longer.
It is better to return by value because you want to use the value of the int-type variable.
And if the int-type does exist longer than the function lifetime, you only win some
efficiency in not having a copy.
The int-type object is small and the compiler can take care of of copies.

- It is sometimes appropriate to return a non-const rvalue reference or a
const rvalue reference to a std::string in the case of move semantics.
However a move constructor is already present for the return type of a std::string,
so returning the std::string by value is ok and the compiler takes care of that.
